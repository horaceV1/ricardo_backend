<?php

/**
 * @file
 * Install, update and uninstall functions for the JWT Auth API module.
 */

/**
 * Implements hook_schema().
 */
function jwt_auth_api_schema() {
  $schema['course_progress'] = [
    'description' => 'Stores course completion progress per user.',
    'fields' => [
      'id' => [
        'description' => 'Primary key.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ],
      'uid' => [
        'description' => 'The user ID.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'course_uuid' => [
        'description' => 'The UUID of the parent course node.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ],
      'course_nid' => [
        'description' => 'The node ID of the parent course.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'status' => [
        'description' => 'The completion status: in_progress or completed.',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => 'in_progress',
      ],
      'current_module' => [
        'description' => 'The index of the current module the user is on.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'total_modules' => [
        'description' => 'Total number of modules in the course.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'completed_at' => [
        'description' => 'Timestamp when the course was completed.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
        'default' => NULL,
      ],
      'created' => [
        'description' => 'Timestamp when the record was created.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'changed' => [
        'description' => 'Timestamp when the record was last updated.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'user_course' => ['uid', 'course_uuid'],
    ],
    'indexes' => [
      'uid' => ['uid'],
      'course_uuid' => ['course_uuid'],
      'status' => ['status'],
    ],
  ];

  $schema['email_verification_codes'] = [
    'description' => 'Stores email verification codes for registration.',
    'fields' => [
      'id' => [
        'description' => 'Primary key.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ],
      'email' => [
        'description' => 'The email address.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ],
      'code' => [
        'description' => 'The 6-digit verification code.',
        'type' => 'varchar',
        'length' => 6,
        'not null' => TRUE,
        'default' => '',
      ],
      'created' => [
        'description' => 'Timestamp when the code was created.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'verified' => [
        'description' => 'Whether the code has been verified.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ],
    ],
    'primary key' => ['id'],
    'indexes' => [
      'email_code' => ['email', 'code'],
      'email' => ['email'],
    ],
  ];

  return $schema;
}

/**
 * Create the course_progress table.
 */
function jwt_auth_api_update_10001() {
  $schema = jwt_auth_api_schema();
  $database = \Drupal::database();
  if (!$database->schema()->tableExists('course_progress')) {
    $database->schema()->createTable('course_progress', $schema['course_progress']);
    return t('Created course_progress table.');
  }
  return t('course_progress table already exists.');
}

/**
 * Create the email_verification_codes table.
 */
function jwt_auth_api_update_10002() {
  $schema = jwt_auth_api_schema();
  $database = \Drupal::database();
  if (!$database->schema()->tableExists('email_verification_codes')) {
    $database->schema()->createTable('email_verification_codes', $schema['email_verification_codes']);
    return t('Created email_verification_codes table.');
  }
  return t('email_verification_codes table already exists.');
}

/**
 * Add field_nif to user_submissions profile type.
 */
function jwt_auth_api_update_10003() {
  $field_storage_config = \Drupal::entityTypeManager()->getStorage('field_storage_config');
  $field_config = \Drupal::entityTypeManager()->getStorage('field_config');

  // Create field storage if it doesn't exist.
  if (!$field_storage_config->load('profile.field_nif')) {
    $field_storage_config->create([
      'field_name' => 'field_nif',
      'entity_type' => 'profile',
      'type' => 'string',
      'settings' => [
        'max_length' => 9,
      ],
      'cardinality' => 1,
    ])->save();
  }

  // Create field instance if it doesn't exist.
  if (!$field_config->load('profile.user_submissions.field_nif')) {
    $field_config->create([
      'field_name' => 'field_nif',
      'entity_type' => 'profile',
      'bundle' => 'user_submissions',
      'label' => 'NIF',
      'description' => 'Número de Identificação Fiscal (9 dígitos)',
      'required' => FALSE,
      'settings' => [],
    ])->save();
  }

  return t('Added field_nif to user_submissions profile.');
}

/**
 * Configure mail system to use HTML mail plugin for jwt_auth_api emails.
 */
function jwt_auth_api_update_10004() {
  $config = \Drupal::configFactory()->getEditable('system.mail');
  $interface = $config->get('interface');
  $interface['jwt_auth_api'] = 'jwt_auth_api_html_mail';
  $config->set('interface', $interface)->save();
  return t('Configured HTML mail plugin for jwt_auth_api.');
}

/**
 * Add fontSize and fontFamily to CKEditor5 full_html toolbar + font color.
 */
function jwt_auth_api_update_10005() {
  // Update the full_html editor to include font toolbar items.
  $editor = \Drupal::entityTypeManager()->getStorage('editor')->load('full_html');
  if ($editor) {
    $settings = $editor->getSettings();

    // Add font toolbar items after existing items.
    $toolbar = $settings['toolbar']['items'] ?? [];
    // Remove existing font items if any to avoid duplicates.
    $toolbar = array_values(array_diff($toolbar, ['fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor']));

    // Insert font items after the heading item.
    $headingPos = array_search('heading', $toolbar);
    if ($headingPos !== FALSE) {
      array_splice($toolbar, $headingPos + 1, 0, ['|', 'fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor']);
    }
    else {
      $toolbar = array_merge($toolbar, ['|', 'fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor']);
    }

    $settings['toolbar']['items'] = $toolbar;

    // Configure font plugin settings with correct key names matching
    // ckeditor_font module expectations (Font.php, FontColor.php, FontBackgroundColor.php).
    $settings['plugins']['ckeditor_font_font'] = [
      'font_sizes' => [
        ['title' => '8', 'model' => '8px'],
        ['title' => '9', 'model' => '9px'],
        ['title' => '10', 'model' => '10px'],
        ['title' => '11', 'model' => '11px'],
        ['title' => '12', 'model' => '12px'],
        ['title' => '14', 'model' => '14px'],
        ['title' => '16', 'model' => '16px'],
        ['title' => '18', 'model' => '18px'],
        ['title' => '20', 'model' => '20px'],
        ['title' => '22', 'model' => '22px'],
        ['title' => '24', 'model' => '24px'],
        ['title' => '26', 'model' => '26px'],
        ['title' => '28', 'model' => '28px'],
        ['title' => '32', 'model' => '32px'],
        ['title' => '36', 'model' => '36px'],
        ['title' => '42', 'model' => '42px'],
        ['title' => '48', 'model' => '48px'],
        ['title' => '56', 'model' => '56px'],
      ],
      'font_names' => [
        "Arial, Helvetica, sans-serif",
        "Georgia, serif",
        "'Courier New', Courier, monospace",
        "'Times New Roman', Times, serif",
        "Verdana, Geneva, sans-serif",
        "Tahoma, Geneva, sans-serif",
        "'Trebuchet MS', Helvetica, sans-serif",
        "Impact, Charcoal, sans-serif",
        "'Comic Sans MS', cursive",
        "'Roboto', sans-serif",
        "'Open Sans', sans-serif",
        "'Lato', sans-serif",
        "'Montserrat', sans-serif",
        "'Poppins', sans-serif",
        "'Raleway', sans-serif",
        "'Nunito', sans-serif",
        "'Oswald', sans-serif",
        "'Playfair Display', serif",
        "'Merriweather', serif",
        "'PT Sans', sans-serif",
        "'Source Sans Pro', sans-serif",
        "'Ubuntu', sans-serif",
        "'Inter', sans-serif",
        "'Nexa-Book', sans-serif",
      ],
      'supportAllSizeValues' => FALSE,
      'supportAllFamilyValues' => TRUE,
    ];

    $settings['plugins']['ckeditor_font_font_color'] = [
      'font_colors' => "#000000|Black\n#333333|Dark Gray\n#666666|Gray\n#999999|Light Gray\n#009999|Teal (Brand)\n#007a7a|Dark Teal\n#ff8c00|Orange (Brand)\n#cc0000|Red\n#0066cc|Blue\n#006600|Green\n#ffffff|White",
      'columns' => 5,
      'documentColors' => 6,
    ];

    $settings['plugins']['ckeditor_font_font_background_color'] = [
      'font_backgroundcolors' => "#ffffff|White\n#f5f5f5|Light Gray\n#ffff00|Yellow\n#009999|Teal\n#ff8c00|Orange\n#ccffcc|Light Green\n#cce5ff|Light Blue\n#ffcccc|Light Red",
      'columns' => 5,
      'documentColors' => 0,
    ];

    // Remove <span class style> from source editing if present — font plugins
    // handle span tags natively, and having it in source editing causes conflicts.
    if (isset($settings['plugins']['ckeditor5_sourceEditing'])) {
      $allowed = $settings['plugins']['ckeditor5_sourceEditing']['allowed_tags'] ?? [];
      $allowed = array_values(array_filter($allowed, function ($tag) {
        return $tag !== '<span class style>' && $tag !== '<span style>';
      }));
      $settings['plugins']['ckeditor5_sourceEditing']['allowed_tags'] = $allowed;
    }

    $editor->setSettings($settings);
    $editor->save();
  }

  // Also update the full_html filter format to allow span with style attribute.
  $format = \Drupal::entityTypeManager()->getStorage('filter_format')->load('full_html');
  if ($format) {
    // Ensure filter_html is not stripping span/style in full_html.
    // full_html typically doesn't use filter_html, so this is a safety check.
    $filters = $format->get('filters');
    if (isset($filters['filter_html']) && !empty($filters['filter_html']['status'])) {
      $allowed = $filters['filter_html']['settings']['allowed_html'] ?? '';
      if (strpos($allowed, '<span') === FALSE) {
        $allowed .= ' <span class style>';
        $filters['filter_html']['settings']['allowed_html'] = $allowed;
        $format->set('filters', $filters);
        $format->save();
      }
    }
  }

  return t('Added fontSize, fontFamily, fontColor, and fontBackgroundColor to CKEditor5 full_html toolbar.');
}

/**
 * Convert homepage string/string_long fields to text_long with full_html.
 *
 * Uses a safe in-place approach: directly modifies DB schema and config
 * entities instead of the destructive delete-recreate approach.
 */
function jwt_auth_api_update_10006() {
  $database = \Drupal::database();
  $config_factory = \Drupal::configFactory();

  // Fields to convert from string_long to text_long (value column is already longtext).
  $string_long_fields = [
    'field_hero_subtitle',
    'field_cta_subtitle',
    'field_feature1_desc',
    'field_feature2_desc',
    'field_feature3_desc',
    'field_feature4_desc',
    'field_features_subtitle',
    'field_formations_subtitle',
    'field_testimonial1_text',
    'field_testimonial2_text',
    'field_testimonial3_text',
    'field_testimonials_subtitle',
  ];

  // Fields to convert from string to text_long (value column needs to change from varchar to longtext).
  $string_fields = [
    'field_hero_badge',
    'field_features_title',
    'field_formations_title',
    'field_testimonials_title',
    'field_cta_title',
    'field_feature1_title',
    'field_feature2_title',
    'field_feature3_title',
    'field_feature4_title',
  ];

  // Skip field_hero_title - already converted to text_long by recovery script.
  $all_fields = array_merge($string_long_fields, $string_fields);
  $converted = 0;

  foreach ($all_fields as $field_name) {
    $field_storage = \Drupal\field\Entity\FieldStorageConfig::loadByName('node', $field_name);
    if (!$field_storage) {
      \Drupal::logger('jwt_auth_api')->warning('Field storage not found for @field, skipping.', ['@field' => $field_name]);
      continue;
    }

    $current_type = $field_storage->getType();
    if ($current_type === 'text_long') {
      // Already converted.
      continue;
    }

    $is_string = ($current_type === 'string');
    $value_column = $field_name . '_value';
    $format_column = $field_name . '_format';
    $tables = ['node__' . $field_name, 'node_revision__' . $field_name];

    foreach ($tables as $table) {
      if (!$database->schema()->tableExists($table)) {
        continue;
      }

      // For string fields, change the value column from varchar(255) to longtext.
      if ($is_string) {
        $database->query("ALTER TABLE {" . $table . "} MODIFY `" . $value_column . "` LONGTEXT");
      }

      // Add the _format column that text_long requires (if it doesn't exist).
      if (!$database->schema()->fieldExists($table, $format_column)) {
        $database->schema()->addField($table, $format_column, [
          'type' => 'varchar_ascii',
          'length' => 255,
          'not null' => FALSE,
        ]);
        // Also add the index on format column.
        try {
          $database->schema()->addIndex($table, $format_column, [$format_column], [
            'fields' => [
              $format_column => [
                'type' => 'varchar_ascii',
                'length' => 255,
              ],
            ],
          ]);
        }
        catch (\Exception $e) {
          // Index might already exist.
        }
      }

      // Set all existing rows to use full_html format.
      $database->update($table)
        ->fields([$format_column => 'full_html'])
        ->isNull($format_column)
        ->execute();
    }

    // Update field storage config type from string/string_long to text_long.
    // We must do this at the config level directly to avoid Drupal's entity
    // system trying to do a schema migration.
    $storage_config_name = 'field.storage.node.' . $field_name;
    $config = $config_factory->getEditable($storage_config_name);
    if ($config) {
      $config->set('type', 'text_long');
      // text_long has different module dependency.
      $config->set('module', 'text');
      // Remove max_length setting if present (string fields have it, text_long doesn't).
      $settings = $config->get('settings') ?: [];
      unset($settings['max_length']);
      unset($settings['is_ascii']);
      unset($settings['case_sensitive']);
      $config->set('settings', $settings);
      $config->save();
    }

    // Update field config (instance) to set allowed_formats.
    $field_config_name = 'field.field.node.homepage.' . $field_name;
    $field_config = $config_factory->getEditable($field_config_name);
    if ($field_config) {
      $field_config->set('field_type', 'text_long');
      $settings = $field_config->get('settings') ?: [];
      $settings['allowed_formats'] = ['full_html'];
      // Remove string-specific settings.
      unset($settings['max_length']);
      $field_config->set('settings', $settings);
      $config_deps = $field_config->get('dependencies.module') ?: [];
      // Replace 'text' for the dependency if not already there.
      if (!in_array('text', $config_deps)) {
        $config_deps[] = 'text';
      }
      $config_deps = array_values(array_diff($config_deps, ['string']));
      $field_config->set('dependencies.module', $config_deps);
      $field_config->save();
    }

    // Update form display widget to text_textarea.
    $form_display = \Drupal::entityTypeManager()->getStorage('entity_form_display')
      ->load('node.homepage.default');
    if ($form_display) {
      $existing = $form_display->getComponent($field_name);
      $form_display->setComponent($field_name, [
        'type' => 'text_textarea',
        'settings' => [
          'rows' => 5,
          'placeholder' => '',
        ],
        'weight' => $existing['weight'] ?? 0,
      ]);
      $form_display->save();
    }

    $converted++;
    \Drupal::logger('jwt_auth_api')->notice('Converted @field from @type to text_long.', [
      '@field' => $field_name,
      '@type' => $current_type,
    ]);
  }

  // Sync Drupal's internal schema tracking so it recognizes the new field types.
  // Three stores need to be updated:
  // 1. entity.storage_schema.sql - tracks the actual DB table schema
  // 2. entity.definitions.installed - tracks installed field definitions
  // 3. entity_field.manager cached definitions

  // Update the SQL storage schema data to match text_long expectations.
  $schema_kv = \Drupal::keyValue('entity.storage_schema.sql');
  foreach ($all_fields as $field_name) {
    $key = 'node.field_schema_data.' . $field_name;
    $data = $schema_kv->get($key);
    if (!$data) {
      continue;
    }

    $value_col = $field_name . '_value';
    $format_col = $field_name . '_format';

    foreach ($data as $table_name => &$table_schema) {
      // Update value column schema to text/big/not null.
      if (isset($table_schema['fields'][$value_col])) {
        $table_schema['fields'][$value_col] = [
          'type' => 'text',
          'size' => 'big',
          'not null' => TRUE,
        ];
      }
      // Add/update format column schema.
      $table_schema['fields'][$format_col] = [
        'type' => 'varchar_ascii',
        'length' => 255,
        'not null' => FALSE,
      ];
      // Add format index.
      $table_schema['indexes'][$format_col] = [$format_col];
    }
    unset($table_schema);

    $schema_kv->set($key, $data);
  }

  // Update the installed field storage definitions to match live config.
  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();
  $live_defs = \Drupal::service('entity_field.manager')->getFieldStorageDefinitions('node');
  $def_kv = \Drupal::keyValue('entity.definitions.installed');
  $stored_defs = $def_kv->get('node.field_storage_definitions');
  foreach ($all_fields as $field_name) {
    if (isset($live_defs[$field_name])) {
      $stored_defs[$field_name] = $live_defs[$field_name];
    }
  }
  $def_kv->set('node.field_storage_definitions', $stored_defs);

  return t('Converted @count homepage text fields to full_html rich text.', ['@count' => $converted]);
}

/**
 * (No-op) Originally added body field to 'curso', but it was not needed.
 *
 * The curso content type already has a text field for blog post content.
 * This hook is kept as a no-op to maintain update hook numbering.
 */
function jwt_auth_api_update_10007() {
  return t('No-op: curso body field addition was reverted (not needed).');
}

/**
 * Also add body field to commerce_product media bundle with full_html.
 */
function jwt_auth_api_update_10008() {
  // The commerce product body field already exists, just ensure it uses full_html.
  $editor = \Drupal::entityTypeManager()->getStorage('editor')->load('full_html');
  if (!$editor) {
    return t('full_html editor not found.');
  }

  // Ensure the full_html format allows all needed HTML for font styling.
  // Add link tag to allowed in source editing for Google Fonts.
  $settings = $editor->getSettings();
  $allowed = $settings['plugins']['ckeditor5_sourceEditing']['allowed_tags'] ?? [];
  $linkTag = '<link rel href>';
  if (!in_array($linkTag, $allowed)) {
    $allowed[] = $linkTag;
  }
  $settings['plugins']['ckeditor5_sourceEditing']['allowed_tags'] = $allowed;
  $editor->setSettings($settings);
  $editor->save();

  // Make sure commerce product body field uses full_html.
  $field_config = \Drupal\field\Entity\FieldConfig::loadByName('commerce_product', 'media', 'body');
  if ($field_config) {
    $settings = $field_config->getSettings();
    $settings['allowed_formats'] = ['full_html'];
    $field_config->setSettings($settings);
    $field_config->save();
  }

  return t('Configured full_html for commerce product body field and added Google Fonts link support.');
}

/**
 * Fix article body to use full_html format + update existing article content.
 */
function jwt_auth_api_update_10009() {
  $database = \Drupal::database();
  $updated = 0;

  // 1. Set article body field to only allow full_html format.
  $field_config = \Drupal\field\Entity\FieldConfig::loadByName('node', 'article', 'body');
  if ($field_config) {
    $settings = $field_config->getSettings();
    $settings['allowed_formats'] = ['full_html'];
    $field_config->setSettings($settings);
    $field_config->save();
    \Drupal::logger('jwt_auth_api')->notice('Set article body to full_html only.');
  }

  // 2. Update all existing article body values from basic_html/plain_text to full_html.
  $tables = ['node__body', 'node_revision__body'];
  foreach ($tables as $table) {
    if ($database->schema()->tableExists($table)) {
      // Get entity IDs for article nodes.
      $article_nids = $database->select('node', 'n')
        ->fields('n', ['nid'])
        ->condition('type', 'article')
        ->execute()
        ->fetchCol();

      if (!empty($article_nids)) {
        $count = $database->update($table)
          ->fields(['body_format' => 'full_html'])
          ->condition('entity_id', $article_nids, 'IN')
          ->condition('body_format', 'full_html', '<>')
          ->execute();
        $updated += $count;
      }
    }
  }

  // 3. Also set page body to allow full_html.
  $page_config = \Drupal\field\Entity\FieldConfig::loadByName('node', 'page', 'body');
  if ($page_config) {
    $settings = $page_config->getSettings();
    $settings['allowed_formats'] = ['full_html'];
    $page_config->setSettings($settings);
    $page_config->save();
  }

  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();

  return t('Fixed article/page body to use full_html. Updated @count existing records.', ['@count' => $updated]);
}
