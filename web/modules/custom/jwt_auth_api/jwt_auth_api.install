<?php

/**
 * @file
 * Install, update and uninstall functions for the JWT Auth API module.
 */

/**
 * Implements hook_schema().
 */
function jwt_auth_api_schema() {
  $schema['course_progress'] = [
    'description' => 'Stores course completion progress per user.',
    'fields' => [
      'id' => [
        'description' => 'Primary key.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ],
      'uid' => [
        'description' => 'The user ID.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'course_uuid' => [
        'description' => 'The UUID of the parent course node.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ],
      'course_nid' => [
        'description' => 'The node ID of the parent course.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'status' => [
        'description' => 'The completion status: in_progress or completed.',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => 'in_progress',
      ],
      'current_module' => [
        'description' => 'The index of the current module the user is on.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'total_modules' => [
        'description' => 'Total number of modules in the course.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'completed_at' => [
        'description' => 'Timestamp when the course was completed.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
        'default' => NULL,
      ],
      'created' => [
        'description' => 'Timestamp when the record was created.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'changed' => [
        'description' => 'Timestamp when the record was last updated.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'user_course' => ['uid', 'course_uuid'],
    ],
    'indexes' => [
      'uid' => ['uid'],
      'course_uuid' => ['course_uuid'],
      'status' => ['status'],
    ],
  ];

  $schema['email_verification_codes'] = [
    'description' => 'Stores email verification codes for registration.',
    'fields' => [
      'id' => [
        'description' => 'Primary key.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ],
      'email' => [
        'description' => 'The email address.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ],
      'code' => [
        'description' => 'The 6-digit verification code.',
        'type' => 'varchar',
        'length' => 6,
        'not null' => TRUE,
        'default' => '',
      ],
      'created' => [
        'description' => 'Timestamp when the code was created.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'verified' => [
        'description' => 'Whether the code has been verified.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ],
    ],
    'primary key' => ['id'],
    'indexes' => [
      'email_code' => ['email', 'code'],
      'email' => ['email'],
    ],
  ];

  return $schema;
}

/**
 * Create the course_progress table.
 */
function jwt_auth_api_update_10001() {
  $schema = jwt_auth_api_schema();
  $database = \Drupal::database();
  if (!$database->schema()->tableExists('course_progress')) {
    $database->schema()->createTable('course_progress', $schema['course_progress']);
    return t('Created course_progress table.');
  }
  return t('course_progress table already exists.');
}

/**
 * Create the email_verification_codes table.
 */
function jwt_auth_api_update_10002() {
  $schema = jwt_auth_api_schema();
  $database = \Drupal::database();
  if (!$database->schema()->tableExists('email_verification_codes')) {
    $database->schema()->createTable('email_verification_codes', $schema['email_verification_codes']);
    return t('Created email_verification_codes table.');
  }
  return t('email_verification_codes table already exists.');
}

/**
 * Add field_nif to user_submissions profile type.
 */
function jwt_auth_api_update_10003() {
  $field_storage_config = \Drupal::entityTypeManager()->getStorage('field_storage_config');
  $field_config = \Drupal::entityTypeManager()->getStorage('field_config');

  // Create field storage if it doesn't exist.
  if (!$field_storage_config->load('profile.field_nif')) {
    $field_storage_config->create([
      'field_name' => 'field_nif',
      'entity_type' => 'profile',
      'type' => 'string',
      'settings' => [
        'max_length' => 9,
      ],
      'cardinality' => 1,
    ])->save();
  }

  // Create field instance if it doesn't exist.
  if (!$field_config->load('profile.user_submissions.field_nif')) {
    $field_config->create([
      'field_name' => 'field_nif',
      'entity_type' => 'profile',
      'bundle' => 'user_submissions',
      'label' => 'NIF',
      'description' => 'Número de Identificação Fiscal (9 dígitos)',
      'required' => FALSE,
      'settings' => [],
    ])->save();
  }

  return t('Added field_nif to user_submissions profile.');
}

/**
 * Configure mail system to use HTML mail plugin for jwt_auth_api emails.
 */
function jwt_auth_api_update_10004() {
  $config = \Drupal::configFactory()->getEditable('system.mail');
  $interface = $config->get('interface');
  $interface['jwt_auth_api'] = 'jwt_auth_api_html_mail';
  $config->set('interface', $interface)->save();
  return t('Configured HTML mail plugin for jwt_auth_api.');
}

/**
 * Add fontSize and fontFamily to CKEditor5 full_html toolbar + font color.
 */
function jwt_auth_api_update_10005() {
  // Update the full_html editor to include font toolbar items.
  $editor = \Drupal::entityTypeManager()->getStorage('editor')->load('full_html');
  if ($editor) {
    $settings = $editor->getSettings();

    // Add font toolbar items after existing items.
    $toolbar = $settings['toolbar']['items'] ?? [];
    // Remove existing font items if any to avoid duplicates.
    $toolbar = array_values(array_diff($toolbar, ['fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor']));

    // Insert font items after the heading item.
    $headingPos = array_search('heading', $toolbar);
    if ($headingPos !== FALSE) {
      array_splice($toolbar, $headingPos + 1, 0, ['|', 'fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor']);
    }
    else {
      $toolbar = array_merge($toolbar, ['|', 'fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor']);
    }

    $settings['toolbar']['items'] = $toolbar;

    // Configure font plugin settings with Google Fonts friendly options.
    $settings['plugins']['ckeditor_font_font'] = [
      'font_size' => [
        '8px|8',
        '9px|9',
        '10px|10',
        '11px|11',
        '12px|12',
        '14px|14',
        '16px|16',
        '18px|18',
        '20px|20',
        '22px|22',
        '24px|24',
        '26px|26',
        '28px|28',
        '32px|32',
        '36px|36',
        '42px|42',
        '48px|48',
        '56px|56',
        '64px|64',
        '72px|72',
      ],
      'font_family' => [
        "Default|",
        "Arial|Arial, Helvetica, sans-serif",
        "Georgia|Georgia, serif",
        "Courier New|'Courier New', Courier, monospace",
        "Times New Roman|'Times New Roman', Times, serif",
        "Verdana|Verdana, Geneva, sans-serif",
        "Tahoma|Tahoma, Geneva, sans-serif",
        "Trebuchet MS|'Trebuchet MS', Helvetica, sans-serif",
        "Impact|Impact, Charcoal, sans-serif",
        "Comic Sans MS|'Comic Sans MS', cursive",
        "Roboto|'Roboto', sans-serif",
        "Open Sans|'Open Sans', sans-serif",
        "Lato|'Lato', sans-serif",
        "Montserrat|'Montserrat', sans-serif",
        "Poppins|'Poppins', sans-serif",
        "Raleway|'Raleway', sans-serif",
        "Nunito|'Nunito', sans-serif",
        "Oswald|'Oswald', sans-serif",
        "Playfair Display|'Playfair Display', serif",
        "Merriweather|'Merriweather', serif",
        "PT Sans|'PT Sans', sans-serif",
        "Source Sans Pro|'Source Sans Pro', sans-serif",
        "Ubuntu|'Ubuntu', sans-serif",
        "Inter|'Inter', sans-serif",
      ],
    ];

    $settings['plugins']['ckeditor_font_font_color'] = [
      'font_color' => [
        '#000000|Black',
        '#333333|Dark Gray',
        '#666666|Gray',
        '#999999|Light Gray',
        '#009999|Teal (Brand)',
        '#007a7a|Dark Teal',
        '#ff8c00|Orange (Brand)',
        '#cc0000|Red',
        '#0066cc|Blue',
        '#006600|Green',
        '#ffffff|White',
      ],
    ];

    $settings['plugins']['ckeditor_font_font_background_color'] = [
      'font_background_color' => [
        '#ffffff|White',
        '#f5f5f5|Light Gray',
        '#ffff00|Yellow',
        '#009999|Teal',
        '#ff8c00|Orange',
        '#ccffcc|Light Green',
        '#cce5ff|Light Blue',
        '#ffcccc|Light Red',
      ],
    ];

    // Make sure source editing allows font styles.
    if (isset($settings['plugins']['ckeditor5_sourceEditing'])) {
      $allowed = $settings['plugins']['ckeditor5_sourceEditing']['allowed_tags'] ?? [];
      $fontTag = '<span class style>';
      if (!in_array($fontTag, $allowed)) {
        $allowed[] = $fontTag;
      }
      $settings['plugins']['ckeditor5_sourceEditing']['allowed_tags'] = $allowed;
    }

    $editor->setSettings($settings);
    $editor->save();
  }

  // Also update the full_html filter format to allow span with style attribute.
  $format = \Drupal::entityTypeManager()->getStorage('filter_format')->load('full_html');
  if ($format) {
    // Ensure filter_html is not stripping span/style in full_html.
    // full_html typically doesn't use filter_html, but let's make sure.
    $filters = $format->get('filters');
    if (isset($filters['filter_html'])) {
      // If filter_html is enabled, update allowed tags.
      $allowed = $filters['filter_html']['settings']['allowed_html'] ?? '';
      if (strpos($allowed, '<span') === FALSE) {
        $allowed .= ' <span class style>';
        $filters['filter_html']['settings']['allowed_html'] = $allowed;
        $format->set('filters', $filters);
        $format->save();
      }
    }
  }

  return t('Added fontSize, fontFamily, fontColor, and fontBackgroundColor to CKEditor5 full_html toolbar.');
}

/**
 * Convert homepage string/string_long fields to text_long with full_html.
 *
 * Uses a safe in-place approach: directly modifies DB schema and config
 * entities instead of the destructive delete-recreate approach.
 */
function jwt_auth_api_update_10006() {
  $database = \Drupal::database();
  $config_factory = \Drupal::configFactory();

  // Fields to convert from string_long to text_long (value column is already longtext).
  $string_long_fields = [
    'field_hero_subtitle',
    'field_cta_subtitle',
    'field_feature1_desc',
    'field_feature2_desc',
    'field_feature3_desc',
    'field_feature4_desc',
    'field_features_subtitle',
    'field_formations_subtitle',
    'field_testimonial1_text',
    'field_testimonial2_text',
    'field_testimonial3_text',
    'field_testimonials_subtitle',
  ];

  // Fields to convert from string to text_long (value column needs to change from varchar to longtext).
  $string_fields = [
    'field_hero_badge',
    'field_features_title',
    'field_formations_title',
    'field_testimonials_title',
    'field_cta_title',
    'field_feature1_title',
    'field_feature2_title',
    'field_feature3_title',
    'field_feature4_title',
  ];

  // Skip field_hero_title - already converted to text_long by recovery script.
  $all_fields = array_merge($string_long_fields, $string_fields);
  $converted = 0;

  foreach ($all_fields as $field_name) {
    $field_storage = \Drupal\field\Entity\FieldStorageConfig::loadByName('node', $field_name);
    if (!$field_storage) {
      \Drupal::logger('jwt_auth_api')->warning('Field storage not found for @field, skipping.', ['@field' => $field_name]);
      continue;
    }

    $current_type = $field_storage->getType();
    if ($current_type === 'text_long') {
      // Already converted.
      continue;
    }

    $is_string = ($current_type === 'string');
    $value_column = $field_name . '_value';
    $format_column = $field_name . '_format';
    $tables = ['node__' . $field_name, 'node_revision__' . $field_name];

    foreach ($tables as $table) {
      if (!$database->schema()->tableExists($table)) {
        continue;
      }

      // For string fields, change the value column from varchar(255) to longtext.
      if ($is_string) {
        $database->query("ALTER TABLE {" . $table . "} MODIFY `" . $value_column . "` LONGTEXT");
      }

      // Add the _format column that text_long requires (if it doesn't exist).
      if (!$database->schema()->fieldExists($table, $format_column)) {
        $database->schema()->addField($table, $format_column, [
          'type' => 'varchar_ascii',
          'length' => 255,
          'not null' => FALSE,
        ]);
        // Also add the index on format column.
        try {
          $database->schema()->addIndex($table, $format_column, [$format_column], [
            'fields' => [
              $format_column => [
                'type' => 'varchar_ascii',
                'length' => 255,
              ],
            ],
          ]);
        }
        catch (\Exception $e) {
          // Index might already exist.
        }
      }

      // Set all existing rows to use full_html format.
      $database->update($table)
        ->fields([$format_column => 'full_html'])
        ->isNull($format_column)
        ->execute();
    }

    // Update field storage config type from string/string_long to text_long.
    // We must do this at the config level directly to avoid Drupal's entity
    // system trying to do a schema migration.
    $storage_config_name = 'field.storage.node.' . $field_name;
    $config = $config_factory->getEditable($storage_config_name);
    if ($config) {
      $config->set('type', 'text_long');
      // text_long has different module dependency.
      $config->set('module', 'text');
      // Remove max_length setting if present (string fields have it, text_long doesn't).
      $settings = $config->get('settings') ?: [];
      unset($settings['max_length']);
      unset($settings['is_ascii']);
      unset($settings['case_sensitive']);
      $config->set('settings', $settings);
      $config->save();
    }

    // Update field config (instance) to set allowed_formats.
    $field_config_name = 'field.field.node.homepage.' . $field_name;
    $field_config = $config_factory->getEditable($field_config_name);
    if ($field_config) {
      $field_config->set('field_type', 'text_long');
      $settings = $field_config->get('settings') ?: [];
      $settings['allowed_formats'] = ['full_html'];
      // Remove string-specific settings.
      unset($settings['max_length']);
      $field_config->set('settings', $settings);
      $config_deps = $field_config->get('dependencies.module') ?: [];
      // Replace 'text' for the dependency if not already there.
      if (!in_array('text', $config_deps)) {
        $config_deps[] = 'text';
      }
      $config_deps = array_values(array_diff($config_deps, ['string']));
      $field_config->set('dependencies.module', $config_deps);
      $field_config->save();
    }

    // Update form display widget to text_textarea.
    $form_display = \Drupal::entityTypeManager()->getStorage('entity_form_display')
      ->load('node.homepage.default');
    if ($form_display) {
      $existing = $form_display->getComponent($field_name);
      $form_display->setComponent($field_name, [
        'type' => 'text_textarea',
        'settings' => [
          'rows' => 5,
          'placeholder' => '',
        ],
        'weight' => $existing['weight'] ?? 0,
      ]);
      $form_display->save();
    }

    $converted++;
    \Drupal::logger('jwt_auth_api')->notice('Converted @field from @type to text_long.', [
      '@field' => $field_name,
      '@type' => $current_type,
    ]);
  }

  // Clear caches to pick up field changes.
  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();

  return t('Converted @count homepage text fields to full_html rich text.', ['@count' => $converted]);
}

/**
 * Add body field to 'curso' (Blog Posts) content type with full_html.
 */
function jwt_auth_api_update_10007() {
  // Check if body field storage already exists for nodes.
  $field_storage = \Drupal\field\Entity\FieldStorageConfig::loadByName('node', 'body');
  if (!$field_storage) {
    // Body field storage should already exist from other content types.
    // Create it if it doesn't.
    $field_storage = \Drupal\field\Entity\FieldStorageConfig::create([
      'field_name' => 'body',
      'entity_type' => 'node',
      'type' => 'text_with_summary',
      'cardinality' => 1,
    ]);
    $field_storage->save();
  }

  // Check if body field already exists on curso bundle.
  $field_config = \Drupal\field\Entity\FieldConfig::loadByName('node', 'curso', 'body');
  if (!$field_config) {
    $field_config = \Drupal\field\Entity\FieldConfig::create([
      'field_storage' => $field_storage,
      'bundle' => 'curso',
      'label' => 'Conteúdo',
      'required' => FALSE,
      'settings' => [
        'display_summary' => TRUE,
        'allowed_formats' => ['full_html'],
      ],
    ]);
    $field_config->save();
  }

  // Set form display.
  $form_display = \Drupal::entityTypeManager()->getStorage('entity_form_display')
    ->load('node.curso.default');
  if ($form_display) {
    $form_display->setComponent('body', [
      'type' => 'text_textarea_with_summary',
      'settings' => [
        'rows' => 12,
        'summary_rows' => 3,
        'placeholder' => '',
        'show_summary' => TRUE,
      ],
      'weight' => 1,
    ]);
    $form_display->save();
  }

  // Set view display.
  $view_display = \Drupal::entityTypeManager()->getStorage('entity_view_display')
    ->load('node.curso.default');
  if ($view_display) {
    $view_display->setComponent('body', [
      'type' => 'text_default',
      'label' => 'hidden',
      'weight' => 1,
    ]);
    $view_display->save();
  }

  return t('Added body field with full_html to Blog Posts (curso) content type.');
}

/**
 * Also add body field to commerce_product media bundle with full_html.
 */
function jwt_auth_api_update_10008() {
  // The commerce product body field already exists, just ensure it uses full_html.
  $editor = \Drupal::entityTypeManager()->getStorage('editor')->load('full_html');
  if (!$editor) {
    return t('full_html editor not found.');
  }

  // Ensure the full_html format allows all needed HTML for font styling.
  // Add link tag to allowed in source editing for Google Fonts.
  $settings = $editor->getSettings();
  $allowed = $settings['plugins']['ckeditor5_sourceEditing']['allowed_tags'] ?? [];
  $linkTag = '<link rel href>';
  if (!in_array($linkTag, $allowed)) {
    $allowed[] = $linkTag;
  }
  $settings['plugins']['ckeditor5_sourceEditing']['allowed_tags'] = $allowed;
  $editor->setSettings($settings);
  $editor->save();

  // Make sure commerce product body field uses full_html.
  $field_config = \Drupal\field\Entity\FieldConfig::loadByName('commerce_product', 'media', 'body');
  if ($field_config) {
    $settings = $field_config->getSettings();
    $settings['allowed_formats'] = ['full_html'];
    $field_config->setSettings($settings);
    $field_config->save();
  }

  return t('Configured full_html for commerce product body field and added Google Fonts link support.');
}

/**
 * Fix article body to use full_html format + update existing article content.
 */
function jwt_auth_api_update_10009() {
  $database = \Drupal::database();
  $updated = 0;

  // 1. Set article body field to only allow full_html format.
  $field_config = \Drupal\field\Entity\FieldConfig::loadByName('node', 'article', 'body');
  if ($field_config) {
    $settings = $field_config->getSettings();
    $settings['allowed_formats'] = ['full_html'];
    $field_config->setSettings($settings);
    $field_config->save();
    \Drupal::logger('jwt_auth_api')->notice('Set article body to full_html only.');
  }

  // 2. Update all existing article body values from basic_html/plain_text to full_html.
  $tables = ['node__body', 'node_revision__body'];
  foreach ($tables as $table) {
    if ($database->schema()->tableExists($table)) {
      // Get entity IDs for article nodes.
      $article_nids = $database->select('node', 'n')
        ->fields('n', ['nid'])
        ->condition('type', 'article')
        ->execute()
        ->fetchCol();

      if (!empty($article_nids)) {
        $count = $database->update($table)
          ->fields(['body_format' => 'full_html'])
          ->condition('entity_id', $article_nids, 'IN')
          ->condition('body_format', 'full_html', '<>')
          ->execute();
        $updated += $count;
      }
    }
  }

  // 3. Also set page body to allow full_html.
  $page_config = \Drupal\field\Entity\FieldConfig::loadByName('node', 'page', 'body');
  if ($page_config) {
    $settings = $page_config->getSettings();
    $settings['allowed_formats'] = ['full_html'];
    $page_config->setSettings($settings);
    $page_config->save();
  }

  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();

  return t('Fixed article/page body to use full_html. Updated @count existing records.', ['@count' => $updated]);
}
